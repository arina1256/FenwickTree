# Дерево Фенвика (Fenwick Tree)
# Лабораторная работа №2 Громовой Арины 24Кнт3


Реализация дерева Фенвика (Binary Indexed Tree) на Java с поддержкой параметризации

## Описание

Дерево Фенвика - это структура данных, которая позволяет эффективно вычислять префиксные суммы и обновлять элементы массива. Данная реализация поддерживает работу с различными числовыми типами.

## Особенности

- **Параметризация**: Поддержка типов `Integer`, `Long`, `Short`
- **Обработка ошибок**: Валидация входных данных

## Функции
### `build(T[] arr)`
**Строит дерево Фенвика из переданного массива**
- `arr` - исходный массив (не может быть null или пустым)
- **Копирует** массив и строит дерево префиксных сумм
- **Проверяет** тип элементов массива


### `get(int index)`
**Возвращает значение элемента по указанному индексу**
- `index` - индекс элемента (0 <= index < tree.length)
- **Вычисляет** значение как разность префиксных сумм
- **Возвращает** элемент типа T

### `prefixSum(int index)`
**Вычисляет префиксную сумму от начала до указанного индекса**
- `index` - конечный индекс включительно
- **Использует** алгоритм дерева Фенвика для эффективного вычисления
- **Возвращает** сумму элементов [0..index]

### `rangeSum(int left, int right)`
**Вычисляет сумму элементов на отрезке [left, right]**
- `left` - начальный индекс
- `right` - конечный индекс
- **Вычисляет** как разность prefixSum(right) - prefixSum(left-1)
- **Проверяет** что left <= right

### `update(int index, T value)`
**Обновляет значение элемента по индексу**
- `index` - индекс обновляемого элемента
- `value` - новое значение (не может быть null)
- **Вычисляет** разность между старым и новым значением
- **Обновляет** все затрагиваемые префиксные суммы

### `updateByValue(int index, T difference)`
**Внутренний метод для обновления дерева на заданную разность**
- `index` - начальный индекс
- `difference` - разность для добавления
- **Используется** внутренне методом update()


### `initializeZeros()`
**Инициализирует дерево нулевыми значениями соответствующего типа**
- **Определяет** тип массива (Integer[], Long[], Short[])
- **Заполняет** нулями правильного типа

### `check_types(Class<T> type)`
**Проверяет поддерживаемость типа данных**
- `type` - класс типа для проверки
- **Допускает** только Integer, Long, Short
- **Выбрасывает** исключение для неподдерживаемых типов

### `add(T a, T b)`
**Сложение двух чисел с проверкой типа**
- `a`, `b` - слагаемые (не могут быть null)
- **Выполняет** сложение в зависимости от runtime-типа
- **Поддерживает** Integer, Long, Short

### `subtract(T a, T b)`
**Вычитание двух чисел с проверкой типа**
- `a`, `b` - уменьшаемое и вычитаемое
- **Выполняет** вычитание в зависимости от типа
- **Поддерживает** Integer, Long, Short

### `createZero()`
**Создает нулевое значение соответствующего типа**
- **Определяет** тип по первому элементу дерева
- **Возвращает** ноль правильного типа (0, 0L, (short)0)

### `checkIndex(int index)`
**Проверяет корректность индекса**
- `index` - проверяемый индекс
- **Проверяет** что дерево инициализировано
- **Проверяет** границы 0 <= index < tree.length
